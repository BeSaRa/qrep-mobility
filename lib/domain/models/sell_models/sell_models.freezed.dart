// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sell_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SellTransaction _$SellTransactionFromJson(Map<String, dynamic> json) {
  return _SellTransaction.fromJson(json);
}

/// @nodoc
mixin _$SellTransaction {
  int get areaCode => throw _privateConstructorUsedError;
  String get issueDate => throw _privateConstructorUsedError;
  int get municipalityId => throw _privateConstructorUsedError;
  int get priceMT => throw _privateConstructorUsedError;
  int get realEstateMT => throw _privateConstructorUsedError;
  int get realEstateSQT => throw _privateConstructorUsedError;
  int get realEstateValue => throw _privateConstructorUsedError;
  int get roi => throw _privateConstructorUsedError;
  String get soldTo => throw _privateConstructorUsedError;
  dynamic get unitNo => throw _privateConstructorUsedError;
  dynamic get unitStatus => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SellTransactionCopyWith<SellTransaction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SellTransactionCopyWith<$Res> {
  factory $SellTransactionCopyWith(
          SellTransaction value, $Res Function(SellTransaction) then) =
      _$SellTransactionCopyWithImpl<$Res, SellTransaction>;
  @useResult
  $Res call(
      {int areaCode,
      String issueDate,
      int municipalityId,
      int priceMT,
      int realEstateMT,
      int realEstateSQT,
      int realEstateValue,
      int roi,
      String soldTo,
      dynamic unitNo,
      dynamic unitStatus});
}

/// @nodoc
class _$SellTransactionCopyWithImpl<$Res, $Val extends SellTransaction>
    implements $SellTransactionCopyWith<$Res> {
  _$SellTransactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? areaCode = null,
    Object? issueDate = null,
    Object? municipalityId = null,
    Object? priceMT = null,
    Object? realEstateMT = null,
    Object? realEstateSQT = null,
    Object? realEstateValue = null,
    Object? roi = null,
    Object? soldTo = null,
    Object? unitNo = freezed,
    Object? unitStatus = freezed,
  }) {
    return _then(_value.copyWith(
      areaCode: null == areaCode
          ? _value.areaCode
          : areaCode // ignore: cast_nullable_to_non_nullable
              as int,
      issueDate: null == issueDate
          ? _value.issueDate
          : issueDate // ignore: cast_nullable_to_non_nullable
              as String,
      municipalityId: null == municipalityId
          ? _value.municipalityId
          : municipalityId // ignore: cast_nullable_to_non_nullable
              as int,
      priceMT: null == priceMT
          ? _value.priceMT
          : priceMT // ignore: cast_nullable_to_non_nullable
              as int,
      realEstateMT: null == realEstateMT
          ? _value.realEstateMT
          : realEstateMT // ignore: cast_nullable_to_non_nullable
              as int,
      realEstateSQT: null == realEstateSQT
          ? _value.realEstateSQT
          : realEstateSQT // ignore: cast_nullable_to_non_nullable
              as int,
      realEstateValue: null == realEstateValue
          ? _value.realEstateValue
          : realEstateValue // ignore: cast_nullable_to_non_nullable
              as int,
      roi: null == roi
          ? _value.roi
          : roi // ignore: cast_nullable_to_non_nullable
              as int,
      soldTo: null == soldTo
          ? _value.soldTo
          : soldTo // ignore: cast_nullable_to_non_nullable
              as String,
      unitNo: freezed == unitNo
          ? _value.unitNo
          : unitNo // ignore: cast_nullable_to_non_nullable
              as dynamic,
      unitStatus: freezed == unitStatus
          ? _value.unitStatus
          : unitStatus // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SellTransactionImplCopyWith<$Res>
    implements $SellTransactionCopyWith<$Res> {
  factory _$$SellTransactionImplCopyWith(_$SellTransactionImpl value,
          $Res Function(_$SellTransactionImpl) then) =
      __$$SellTransactionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int areaCode,
      String issueDate,
      int municipalityId,
      int priceMT,
      int realEstateMT,
      int realEstateSQT,
      int realEstateValue,
      int roi,
      String soldTo,
      dynamic unitNo,
      dynamic unitStatus});
}

/// @nodoc
class __$$SellTransactionImplCopyWithImpl<$Res>
    extends _$SellTransactionCopyWithImpl<$Res, _$SellTransactionImpl>
    implements _$$SellTransactionImplCopyWith<$Res> {
  __$$SellTransactionImplCopyWithImpl(
      _$SellTransactionImpl _value, $Res Function(_$SellTransactionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? areaCode = null,
    Object? issueDate = null,
    Object? municipalityId = null,
    Object? priceMT = null,
    Object? realEstateMT = null,
    Object? realEstateSQT = null,
    Object? realEstateValue = null,
    Object? roi = null,
    Object? soldTo = null,
    Object? unitNo = freezed,
    Object? unitStatus = freezed,
  }) {
    return _then(_$SellTransactionImpl(
      areaCode: null == areaCode
          ? _value.areaCode
          : areaCode // ignore: cast_nullable_to_non_nullable
              as int,
      issueDate: null == issueDate
          ? _value.issueDate
          : issueDate // ignore: cast_nullable_to_non_nullable
              as String,
      municipalityId: null == municipalityId
          ? _value.municipalityId
          : municipalityId // ignore: cast_nullable_to_non_nullable
              as int,
      priceMT: null == priceMT
          ? _value.priceMT
          : priceMT // ignore: cast_nullable_to_non_nullable
              as int,
      realEstateMT: null == realEstateMT
          ? _value.realEstateMT
          : realEstateMT // ignore: cast_nullable_to_non_nullable
              as int,
      realEstateSQT: null == realEstateSQT
          ? _value.realEstateSQT
          : realEstateSQT // ignore: cast_nullable_to_non_nullable
              as int,
      realEstateValue: null == realEstateValue
          ? _value.realEstateValue
          : realEstateValue // ignore: cast_nullable_to_non_nullable
              as int,
      roi: null == roi
          ? _value.roi
          : roi // ignore: cast_nullable_to_non_nullable
              as int,
      soldTo: null == soldTo
          ? _value.soldTo
          : soldTo // ignore: cast_nullable_to_non_nullable
              as String,
      unitNo: freezed == unitNo ? _value.unitNo! : unitNo,
      unitStatus: freezed == unitStatus ? _value.unitStatus! : unitStatus,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SellTransactionImpl implements _SellTransaction {
  const _$SellTransactionImpl(
      {this.areaCode = 0,
      this.issueDate = '',
      this.municipalityId = 0,
      this.priceMT = 0,
      this.realEstateMT = 0,
      this.realEstateSQT = 0,
      this.realEstateValue = 0,
      this.roi = 0,
      this.soldTo = '',
      this.unitNo = 0,
      this.unitStatus = 0});

  factory _$SellTransactionImpl.fromJson(Map<String, dynamic> json) =>
      _$$SellTransactionImplFromJson(json);

  @override
  @JsonKey()
  final int areaCode;
  @override
  @JsonKey()
  final String issueDate;
  @override
  @JsonKey()
  final int municipalityId;
  @override
  @JsonKey()
  final int priceMT;
  @override
  @JsonKey()
  final int realEstateMT;
  @override
  @JsonKey()
  final int realEstateSQT;
  @override
  @JsonKey()
  final int realEstateValue;
  @override
  @JsonKey()
  final int roi;
  @override
  @JsonKey()
  final String soldTo;
  @override
  @JsonKey()
  final dynamic unitNo;
  @override
  @JsonKey()
  final dynamic unitStatus;

  @override
  String toString() {
    return 'SellTransaction(areaCode: $areaCode, issueDate: $issueDate, municipalityId: $municipalityId, priceMT: $priceMT, realEstateMT: $realEstateMT, realEstateSQT: $realEstateSQT, realEstateValue: $realEstateValue, roi: $roi, soldTo: $soldTo, unitNo: $unitNo, unitStatus: $unitStatus)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SellTransactionImpl &&
            (identical(other.areaCode, areaCode) ||
                other.areaCode == areaCode) &&
            (identical(other.issueDate, issueDate) ||
                other.issueDate == issueDate) &&
            (identical(other.municipalityId, municipalityId) ||
                other.municipalityId == municipalityId) &&
            (identical(other.priceMT, priceMT) || other.priceMT == priceMT) &&
            (identical(other.realEstateMT, realEstateMT) ||
                other.realEstateMT == realEstateMT) &&
            (identical(other.realEstateSQT, realEstateSQT) ||
                other.realEstateSQT == realEstateSQT) &&
            (identical(other.realEstateValue, realEstateValue) ||
                other.realEstateValue == realEstateValue) &&
            (identical(other.roi, roi) || other.roi == roi) &&
            (identical(other.soldTo, soldTo) || other.soldTo == soldTo) &&
            const DeepCollectionEquality().equals(other.unitNo, unitNo) &&
            const DeepCollectionEquality()
                .equals(other.unitStatus, unitStatus));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      areaCode,
      issueDate,
      municipalityId,
      priceMT,
      realEstateMT,
      realEstateSQT,
      realEstateValue,
      roi,
      soldTo,
      const DeepCollectionEquality().hash(unitNo),
      const DeepCollectionEquality().hash(unitStatus));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SellTransactionImplCopyWith<_$SellTransactionImpl> get copyWith =>
      __$$SellTransactionImplCopyWithImpl<_$SellTransactionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SellTransactionImplToJson(
      this,
    );
  }
}

abstract class _SellTransaction implements SellTransaction {
  const factory _SellTransaction(
      {final int areaCode,
      final String issueDate,
      final int municipalityId,
      final int priceMT,
      final int realEstateMT,
      final int realEstateSQT,
      final int realEstateValue,
      final int roi,
      final String soldTo,
      final dynamic unitNo,
      final dynamic unitStatus}) = _$SellTransactionImpl;

  factory _SellTransaction.fromJson(Map<String, dynamic> json) =
      _$SellTransactionImpl.fromJson;

  @override
  int get areaCode;
  @override
  String get issueDate;
  @override
  int get municipalityId;
  @override
  int get priceMT;
  @override
  int get realEstateMT;
  @override
  int get realEstateSQT;
  @override
  int get realEstateValue;
  @override
  int get roi;
  @override
  String get soldTo;
  @override
  dynamic get unitNo;
  @override
  dynamic get unitStatus;
  @override
  @JsonKey(ignore: true)
  _$$SellTransactionImplCopyWith<_$SellTransactionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SellTransactionResponse _$SellTransactionResponseFromJson(
    Map<String, dynamic> json) {
  return _SellResponse.fromJson(json);
}

/// @nodoc
mixin _$SellTransactionResponse {
  int get count => throw _privateConstructorUsedError;
  List<SellTransaction> get transactionList =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SellTransactionResponseCopyWith<SellTransactionResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SellTransactionResponseCopyWith<$Res> {
  factory $SellTransactionResponseCopyWith(SellTransactionResponse value,
          $Res Function(SellTransactionResponse) then) =
      _$SellTransactionResponseCopyWithImpl<$Res, SellTransactionResponse>;
  @useResult
  $Res call({int count, List<SellTransaction> transactionList});
}

/// @nodoc
class _$SellTransactionResponseCopyWithImpl<$Res,
        $Val extends SellTransactionResponse>
    implements $SellTransactionResponseCopyWith<$Res> {
  _$SellTransactionResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? transactionList = null,
  }) {
    return _then(_value.copyWith(
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      transactionList: null == transactionList
          ? _value.transactionList
          : transactionList // ignore: cast_nullable_to_non_nullable
              as List<SellTransaction>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SellResponseImplCopyWith<$Res>
    implements $SellTransactionResponseCopyWith<$Res> {
  factory _$$SellResponseImplCopyWith(
          _$SellResponseImpl value, $Res Function(_$SellResponseImpl) then) =
      __$$SellResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int count, List<SellTransaction> transactionList});
}

/// @nodoc
class __$$SellResponseImplCopyWithImpl<$Res>
    extends _$SellTransactionResponseCopyWithImpl<$Res, _$SellResponseImpl>
    implements _$$SellResponseImplCopyWith<$Res> {
  __$$SellResponseImplCopyWithImpl(
      _$SellResponseImpl _value, $Res Function(_$SellResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? transactionList = null,
  }) {
    return _then(_$SellResponseImpl(
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      transactionList: null == transactionList
          ? _value._transactionList
          : transactionList // ignore: cast_nullable_to_non_nullable
              as List<SellTransaction>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SellResponseImpl implements _SellResponse {
  const _$SellResponseImpl(
      {this.count = 0, final List<SellTransaction> transactionList = const []})
      : _transactionList = transactionList;

  factory _$SellResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$SellResponseImplFromJson(json);

  @override
  @JsonKey()
  final int count;
  final List<SellTransaction> _transactionList;
  @override
  @JsonKey()
  List<SellTransaction> get transactionList {
    if (_transactionList is EqualUnmodifiableListView) return _transactionList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_transactionList);
  }

  @override
  String toString() {
    return 'SellTransactionResponse(count: $count, transactionList: $transactionList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SellResponseImpl &&
            (identical(other.count, count) || other.count == count) &&
            const DeepCollectionEquality()
                .equals(other._transactionList, _transactionList));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, count,
      const DeepCollectionEquality().hash(_transactionList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SellResponseImplCopyWith<_$SellResponseImpl> get copyWith =>
      __$$SellResponseImplCopyWithImpl<_$SellResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SellResponseImplToJson(
      this,
    );
  }
}

abstract class _SellResponse implements SellTransactionResponse {
  const factory _SellResponse(
      {final int count,
      final List<SellTransaction> transactionList}) = _$SellResponseImpl;

  factory _SellResponse.fromJson(Map<String, dynamic> json) =
      _$SellResponseImpl.fromJson;

  @override
  int get count;
  @override
  List<SellTransaction> get transactionList;
  @override
  @JsonKey(ignore: true)
  _$$SellResponseImplCopyWith<_$SellResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
